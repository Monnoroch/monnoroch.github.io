<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      Go-inject — Dependency Injection Library for Go &middot; 
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/styles.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">
</head>


<body>
    <nav class="nav">
        <div class="nav-container">
            <a href="/">
                <h2 class="nav-title"></h2>
            </a>
            <ul>
                <li><a href="/about">About</a></li>
                <li><a href="/">All posts</a></li>
            </ul>
            
                
            
                
                    
                        <a href="/ru/posts/2018/10/27/go-inject-dependency-injection-library-for-go.html">
                            Russian
                        </a>
                    
                    
                    
                
            
        </div>
    </nav>
    <main>
        <div class="post">
  <div class="post-info">
    <span>Written by</span>
    
        Max Strakhov
    

    
      <br>
      <span>on&nbsp;</span><time datetime="2018-10-27 09:00:00 +0000">October 27, 2018</time>
    
  </div>

  <h1 class="post-title">Go-inject — Dependency Injection Library for Go</h1>
  <div class="post-line"></div>

  <p>There are many resources on the web that try to define and explain <a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a> (a.k.a. DI). DI is a very useful software engineering technique, yet Go lacks any established libraries for it (although there were some attempts, which we will take a look at below). Not anymore! In this post we will introduce the <a href="https://github.com/monnoroch/go-inject">go-inject</a> library and explore how it can improve code quality in standard Go application domain — web servers.</p>

<p>First, let us imagine we&#39;re a modern software startup whose product is an app that shows the weather. Our app&#39;s killer feature that will surely let us dominate weather prediction market is AI-based weather prediction. And of course, being a software startup, we need to build a cloud-native backend made of many microservices. Fortunately for us, our cloud provider is a company on the bleeding edge of AI research and it already had built a universal conversational AI and provided it to us as a <a href="https://grpc.io">gRPC</a>-based API. If you don&#39;t know gRPC, don&#39;t worry, you can treat gRPC service definitions below as pseudocode that is used to auto-generate Go code with specified data structures and interfaces. This is how our system will look like:</p>

<p><center>
    <img src="/images/posts/2018-10-22-go-inject-dependency-injection-library-for-go/architecture-1.svg"/>
</center>
<center>
Fig 1. Weather prediction service architecture.
</center></p>

<p>Here is the gRPC service definition for the General AI service: it&#39;s a service for answering questions.</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/88e8aca7c1b10aa3ac8dae23fefbc496cb3a63ef/examples/weather/proto/ai/ai.proto"><code>ai.proto</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-proto" data-lang="proto"><span></span><span class="kd">service</span> <span class="n">Ai</span> <span class="p">{</span>
    <span class="k">rpc</span> <span class="n">Ask</span><span class="p">(</span><span class="n">Question</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">Answer</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">Question</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="na">question</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">Answer</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="na">answer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>The AI is simply a service that can give us free-form answers for free-form questions. Very powerful indeed. Now, there is a chance that the current version of the AI might just reply &quot;42&quot; to everything, but we&#39;re a startup and surely we can&#39;t build our own AI, right?</p>

<p>Let&#39;s take a closer look at our first microservice. It will use the above AI service to predict weather conditions for a specified space-time location:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/88e8aca7c1b10aa3ac8dae23fefbc496cb3a63ef/examples/weather/proto/weather.proto"><code>weather.proto</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-proto" data-lang="proto"><span></span><span class="kd">service</span> <span class="n">WeatherPrediction</span> <span class="p">{</span>
    <span class="k">rpc</span> <span class="n">Predict</span><span class="p">(</span><span class="n">SpaceTimeLocation</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">Weather</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">SpaceTimeLocation</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="na">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int64</span> <span class="na">timestamp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">Weather</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="na">weather</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Alright, the service API is defined, now it&#39;s time to implement it. We&#39;re going to be good engineers and separate user request handling logic and AI service interaction logic. Let&#39;s first implement the AI client. It&#39;s going to be a simple component that encapsulates the AI service API:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/88e8aca7c1b10aa3ac8dae23fefbc496cb3a63ef/examples/weather/ai/client.go"><code>ai/client.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">type</span> <span class="nx">AiClient</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">RawAiClient</span> <span class="nx">aiproto</span><span class="p">.</span><span class="nx">AiClient</span>
<span class="p">}</span>

<span class="c1">/// Ask AI service for weather at location and time specified in arguments.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">AiClient</span><span class="p">)</span> <span class="nx">AskForWeather</span><span class="p">(</span>
    <span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span>
    <span class="nx">location</span> <span class="kt">string</span><span class="p">,</span>
    <span class="nx">timestamp</span> <span class="kt">int64</span><span class="p">,</span>
<span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">answer</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">RawAiClient</span><span class="p">.</span><span class="nx">Ask</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">aiproto</span><span class="p">.</span><span class="nx">Question</span><span class="p">{</span>
        <span class="nx">Question</span><span class="p">:</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span>
            <span class="s">&quot;What&#39;s the weather at location &#39;%s&#39; at time &#39;%d&#39;&quot;</span><span class="p">,</span>
            <span class="nx">location</span><span class="p">,</span>
            <span class="nx">timestamp</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">})</span>
    <span class="k">return</span> <span class="nx">answer</span><span class="p">.</span><span class="nx">GetAnswer</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<p>In this case we only have one method so we didn&#39;t need to have a struct. However, our sales team has already sold ten additional features to our customers that require using the AI service, so we know this component will grow and might as well just create a struct right away. Also note how we omit error handling: this is fine for a blog post, but terrible for production code. Don&#39;t do that.</p>

<p>Now that we have a way to obtain weather predictions, let&#39;s actually implement our weather prediction service. It&#39;s going to be a simple gRPC service, that uses our AI client, registered with a standard gRPC server:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/88e8aca7c1b10aa3ac8dae23fefbc496cb3a63ef/examples/weather/main.go"><code>main.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">type</span> <span class="nx">Server</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">AiClient</span> <span class="nx">ai</span><span class="p">.</span><span class="nx">AiClient</span>
<span class="p">}</span>

<span class="c1">/// Handler for the WeatherPrediction.Predict RPC.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nx">Predict</span><span class="p">(</span>
    <span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span>
    <span class="nx">request</span> <span class="o">*</span><span class="nx">proto</span><span class="p">.</span><span class="nx">SpaceTimeLocation</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">proto</span><span class="p">.</span><span class="nx">Weather</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">weather</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">AiClient</span><span class="p">.</span><span class="nx">AskForWeather</span><span class="p">(</span>
        <span class="nx">ctx</span><span class="p">,</span>
        <span class="nx">request</span><span class="p">.</span><span class="nx">GetLocation</span><span class="p">(),</span>
        <span class="nx">request</span><span class="p">.</span><span class="nx">GetTimestamp</span><span class="p">(),</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">proto</span><span class="p">.</span><span class="nx">Weather</span><span class="p">{</span><span class="nx">Weather</span><span class="p">:</span> <span class="nx">weather</span><span class="p">},</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">aiConnection</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&quot;ai-service:80&quot;</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">WithInsecure</span><span class="p">())</span>
    <span class="nx">weatherPredictionServer</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Server</span><span class="p">{</span>
        <span class="nx">AiClient</span><span class="p">:</span> <span class="nx">ai</span><span class="p">.</span><span class="nx">AiClient</span><span class="p">{</span>
            <span class="nx">RawAiClient</span><span class="p">:</span> <span class="nx">aiproto</span><span class="p">.</span><span class="nx">NewAiClient</span><span class="p">(</span><span class="nx">aiConnection</span><span class="p">),</span>
        <span class="p">},</span>
    <span class="p">}</span>
    <span class="nx">server</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">NewServer</span><span class="p">()</span>
    <span class="nx">proto</span><span class="p">.</span><span class="nx">RegisterWeatherPredictionServer</span><span class="p">(</span>
        <span class="nx">server</span><span class="p">,</span>
        <span class="nx">weatherPredictionServer</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nx">listener</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listen</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;:80&quot;</span><span class="p">)</span>
    <span class="nx">server</span><span class="p">.</span><span class="nx">Serve</span><span class="p">(</span><span class="nx">listener</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>All done! Is there anything wrong with this code? Not really, but one thing one can notice right away is that request handling code is modular and follows the single responsibility principle, while the setup code in main is not as modular. In fact, it&#39;s just a bunch of spaghetti code wiring up the components. Imagine, what will happen to it when our RPC service has twenty RPC methods, ten external dependencies and fifty components developed by five engineers!</p>

<p>Ok, let&#39;s refactor the main function a little bit. Each component should have it&#39;s set up function that would later go to the component&#39;s package:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/002bf413f52e5544ff4eb03f0f31a6bd6f9a6142/examples/weather/main.go"><code>main.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">func</span> <span class="nx">AiServiceEndpoint</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;ai-service:80&quot;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewAiServiceGrpcConnection</span><span class="p">()</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span> <span class="p">{</span>
    <span class="nx">connection</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="nx">AiServiceEndpoint</span><span class="p">(),</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">WithInsecure</span><span class="p">())</span>
    <span class="k">return</span> <span class="nx">connection</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewGrpcAiClient</span><span class="p">()</span> <span class="nx">aiproto</span><span class="p">.</span><span class="nx">AiClient</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">aiproto</span><span class="p">.</span><span class="nx">NewAiClient</span><span class="p">(</span><span class="nx">NewAiServiceGrpcConnection</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewAiClient</span><span class="p">()</span> <span class="nx">ai</span><span class="p">.</span><span class="nx">AiClient</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">ai</span><span class="p">.</span><span class="nx">AiClient</span><span class="p">{</span><span class="nx">RawAiClient</span><span class="p">:</span> <span class="nx">NewGrpcAiClient</span><span class="p">()}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewServer</span><span class="p">()</span> <span class="o">*</span><span class="nx">Server</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Server</span><span class="p">{</span><span class="nx">AiClient</span><span class="p">:</span> <span class="nx">NewAiClient</span><span class="p">()}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">weatherPredictionServer</span> <span class="o">:=</span> <span class="nx">NewServer</span><span class="p">()</span>

    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div>
<p>Much more readable now! However, these constructor functions can&#39;t be put in their own packages close to the types they construct, because, for example, the AI client package is not supposed to know which URL does it need to connect to. Also this code is still not great, as there&#39;s no way to reuse it in different contexts. For example, we can not create an AI client to talk to a different endpoint to be used in a different gRPC server. Let&#39;s try to fix this issue by not hard coding dependencies but receiving them as arguments instead:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/a693800c9ccbf1ce3e45467329182e481a7c2768/examples/weather/main.go"><code>main.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">func</span> <span class="nx">AiServiceEndpoint</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;ai-service:80&quot;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewAiServiceGrpcConnection</span><span class="p">(</span><span class="nx">aiServiceEndpoint</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span> <span class="p">{</span>
    <span class="nx">connection</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="nx">aiServiceEndpoint</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">WithInsecure</span><span class="p">())</span>
    <span class="k">return</span> <span class="nx">connection</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewGrpcAiClient</span><span class="p">(</span><span class="nx">connection</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nx">aiproto</span><span class="p">.</span><span class="nx">AiClient</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">aiproto</span><span class="p">.</span><span class="nx">NewAiClient</span><span class="p">(</span><span class="nx">connection</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewAiClient</span><span class="p">(</span><span class="nx">aiClient</span> <span class="nx">aiproto</span><span class="p">.</span><span class="nx">AiClient</span><span class="p">)</span> <span class="nx">ai</span><span class="p">.</span><span class="nx">AiClient</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">ai</span><span class="p">.</span><span class="nx">AiClient</span><span class="p">{</span><span class="nx">RawAiClient</span><span class="p">:</span> <span class="nx">aiClient</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewServer</span><span class="p">(</span><span class="nx">client</span> <span class="nx">ai</span><span class="p">.</span><span class="nx">AiClient</span><span class="p">)</span> <span class="o">*</span><span class="nx">Server</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Server</span><span class="p">{</span><span class="nx">AiClient</span><span class="p">:</span> <span class="nx">client</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">endpoint</span> <span class="o">:=</span> <span class="nx">AiServiceEndpoint</span><span class="p">()</span>
    <span class="nx">connection</span> <span class="o">:=</span> <span class="nx">NewAiServiceGrpcConnection</span><span class="p">(</span><span class="nx">endpoint</span><span class="p">)</span>
    <span class="nx">aiClient</span> <span class="o">:=</span> <span class="nx">NewAiClient</span><span class="p">(</span><span class="nx">NewGrpcAiClient</span><span class="p">(</span><span class="nx">connection</span><span class="p">))</span>
    <span class="nx">weatherPredictionServer</span> <span class="o">:=</span> <span class="nx">NewServer</span><span class="p">(</span><span class="nx">aiClient</span><span class="p">)</span>

    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div>
<p>Ok, now we have reusable constructor functions for all components, which we can actually put in different packages, but we&#39;re back to spaghetti code in main. Is there no way to write maintainable setup code?! Well, we can continue refactoring main and split it into a few helper functions with good readable names. However, there&#39;s a fundamental problem here: either you have configurable constructors that accept dependencies as arguments and then you write spaghetti code to wire them together, or you hard code these dependencies and not reuse your constructor functions. There&#39;s no way around that, no matter how much you refactor your code.</p>

<p>Or is there? Let&#39;s imagine a system that allows us to write independent, reusable chunks of code for creating components, just as we did in the last example, and then automatically generates all the spaghetti code that we have in main. Can this be done? Indeed it can! This is what <code>go-inject</code> and any other Dependency Injection library does. Two most popular examples and the ones I&#39;m most familiar with are <a href="https://github.com/google/guice">Guice</a> and <a href="https://google.github.io/dagger">Dagger</a>. Both are Java frameworks, which implies a heavy weight approach with infinite configurability and thousands of features. Can a similar tool be designed for Go with Go&#39;s strengths and philosophy in mind? Well, there&#39;s no harm in trying, so let&#39;s do just that.</p>

<h2>Dependency Injection Library for Go</h2>

<p>But let&#39;s discuss this idea for a bit first. People who moved from Java to Go will immediately be alert at this point. They, just like me, probably moved for Go&#39;s simplicity, the culture to be explicit and tools that are stupid (in a good way) rather than clever and complicated, which is what we see in Java a lot. If I were to build a Dependency Injection library, it would have to be aligned with Go&#39;s core values.</p>

<h4>It has to do one thing only</h4>

<p>Namely, generate boilerplate for wiring up dependencies. Libraries that do many loosely related things are unwelcome in Go. This doesn&#39;t mean a library has to be small in size though, for example, <code>net/http</code> package is quite big, but it still does only one job — implements a generic HTTP server.</p>

<h4>The API needs to be expressive</h4>

<p>All common patterns have to be supported along with as many reasonable uncommon ones as possible. <code>net/http</code> is also a great example here: I have never found any missing features or lacking flexibility there for day-to-day software (although you might want to use <code>fasthttp</code> if your infrastructure doesn&#39;t scale horizontally or the deployment is huge and bound by the HTTP server).</p>

<h4>The API also needs to be concise</h4>

<p>There should be user-friendly helpers for common patterns. Just as <code>encoding/json</code> package allows adding <code>json:</code> annotations instead of implementing the complicated <code>RawMessage</code> interface, our DI library needs to provide syntactic-sugar-like helpers for common operations.</p>

<h4>The library needs to be transparent</h4>

<p>The implementation needs to be simple and hackable. This is the bit that is often missed by software engineers. There is a culture that if your interface is good, the implementation doesn&#39;t matter all that much. However, the truth is that all abstractions leak. Your new abstraction will also leak. People <em>will</em> have to look at the implementation from time to time, either to understand it, or to fix a problem, or maybe even to bypass your abstraction in a context you just didn&#39;t anticipate. One of the best parts of switching to Go for me was that I can easily read and understand the source code of most good libraries. This is much less true in many other software engineering cultures.</p>

<h4>Backward compatibility</h4>

<p>Existing code should not require modification to use a DI library. New code can be made DI-library aware to get convenience features, but should not be required to do so. Backwards compatibility is a must for seamless integration with both existing code and third party libraries.</p>

<h4>It has to feel like a Go library</h4>

<p>In addition to all the above formal criteria, a DI library for Go just has to feel native. For example, it has to leverage type system as much as possible, make it easy to build tools on top of it and be Go-ish in general. This is not easy to formalize, but very easy to feel.</p>

<h2>Enter go-inject</h2>

<p>A piece of code is worth a thousand words, so let&#39;s just reimplement our main function above with <code>go-inject</code> and then discuss the implementation. Here&#39;s a first simplistic pseudo-implementation:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/316fe41bb3d0c7e82edd731d6215aec78a302efd/examples/weather/grpc/module.go"><code>grpc/module.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="c1">/// A module for providing gRPC client components.</span>
<span class="kd">type</span> <span class="nx">GrpcClientModule</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">GrpcClientModule</span><span class="p">)</span> <span class="nx">ProvideConnection</span><span class="p">(</span>
    <span class="nx">endpoint</span> <span class="kt">string</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">connection</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="nx">endpoint</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">WithInsecure</span><span class="p">())</span>
    <span class="k">return</span> <span class="nx">connection</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="https://github.com/Monnoroch/go-inject/blob/316fe41bb3d0c7e82edd731d6215aec78a302efd/examples/weather/ai/client.go"><code>ai/client.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="c1">/// A module for providing AI service client components.</span>
<span class="kd">type</span> <span class="nx">AiServiceClientModule</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">AiServiceClientModule</span><span class="p">)</span> <span class="nx">ProvideGrpcClient</span><span class="p">(</span>
    <span class="nx">connection</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">aiproto</span><span class="p">.</span><span class="nx">AiClient</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">aiproto</span><span class="p">.</span><span class="nx">NewAiClient</span><span class="p">(</span><span class="nx">connection</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">AiServiceClientModule</span><span class="p">)</span> <span class="nx">ProvideAiClient</span><span class="p">(</span>
    <span class="nx">client</span> <span class="nx">aiproto</span><span class="p">.</span><span class="nx">AiClient</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">AiClient</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">AiClient</span><span class="p">{</span><span class="nx">RawAiClient</span><span class="p">:</span> <span class="nx">client</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="https://github.com/Monnoroch/go-inject/blob/316fe41bb3d0c7e82edd731d6215aec78a302efd/examples/weather/main.go"><code>main.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kn">import</span> <span class="s">&quot;github.com/monnoroch/go-inject&quot;</span>

<span class="c1">/// A module for providing a configured weather prediction server.</span>
<span class="kd">type</span> <span class="nx">WeatherPredictionServerModule</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">/// Provider returning the AI service endpoint, to be used by the gRPC client module.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">WeatherPredictionServerModule</span><span class="p">)</span> <span class="nx">ProvideGrpcEndpoint</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;ai-service:80&quot;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">WeatherPredictionServerModule</span><span class="p">)</span> <span class="nx">ProvideServer</span><span class="p">(</span>
    <span class="nx">client</span> <span class="nx">ai</span><span class="p">.</span><span class="nx">AiClient</span><span class="p">,</span>
<span class="p">)</span> <span class="o">*</span><span class="nx">Server</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Server</span><span class="p">{</span><span class="nx">AiClient</span><span class="p">:</span> <span class="nx">client</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">injector</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">InjectorOf</span><span class="p">(</span>
        <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClientModule</span><span class="p">{},</span>
        <span class="nx">ai</span><span class="p">.</span><span class="nx">AiServiceClientModule</span><span class="p">{},</span>
        <span class="nx">WeatherPredictionServerModule</span><span class="p">{},</span>
    <span class="p">)</span>
    <span class="nx">weatherPredictionServer</span> <span class="o">:=</span> <span class="nx">injector</span><span class="p">.</span><span class="nx">MustGet</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="o">*</span><span class="nx">Server</span><span class="p">)).(</span><span class="o">*</span><span class="nx">Server</span><span class="p">)</span>

    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div>
<p>Doesn&#39;t look that simple, eh? Well, let&#39;s take a closer look before judging. Ok, so we grouped our glue code into three structs called modules: gRPC client module, AI service client module and the weather prediction server module. Each module can be put in the corresponding package and unit-tested separately. For example, we placed the AI service client module to the <code>ai</code> package and even made the gRPC client module into a general-purpose library. Each module has providers — methods named <code>ProvideSomething</code>. These methods each return one of the components used in our application and receive it&#39;s dependencies as arguments. Notice how these providers map directly to constructor functions from the second main refactoring example above. In these providers we do not hardcode the dependencies, so they are reusable in multiple contexts.</p>

<p>Okay, we converted our constructors into struct methods, so not much changed just yet. We even had to write a bit more boilerplate to have methods instead of functions. So how is this better? Enter <code>Injector</code>. Injector is a core component of the library. An injector is configured with a collection of modules and can provide all the components by calling providers and automatically wiring up all their dependencies. Basically, the <code>injector.MustGet(new(*Server)).(*Server)</code> call generates all the boilerplate we had to write before for creating a server instance using configurable constructor functions. Another interesting point to note is that we are not ignoring errors that <code>grpc.Dial</code> can return, but our code is still clear of error-handling code. That is because <code>go-inject</code> handles all errors returned from providers for you and bubbles them up to the caller. A nice thing to get for free, isn&#39;t it?</p>

<p>In short, we put our constructor functions into modules as providers, configure the injector with a collection of modules and then use it to dynamically generate component creation code.</p>

<p>Now, you might have spotted a problem with this code: what if we have two providers returning a <code>string</code>? Which one will the system pick? Well, there&#39;s no way for it to decide, so we have to do something about it. Similar to <a href="https://github.com/google/guice/wiki/BindingAnnotations">Guice</a>, <code>go-inject</code> requires the user to mark annotate all values, so that if there are two <code>string</code> providers, these strings are annotated differently and when you depend on a <code>string</code> you also specify which string this is. Unlike Java, Go doesn&#39;t have any built-in syntax for annotating declarations, so we have to improvise. The option I chose for <code>go-inject</code> is to always declare dependencies in pairs: a value type and an annotation type. It&#39;s much easier to explain with code, so here&#39;s the version of the above code with annotations:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/96ebd38a01cb954d5cdc8f4047bbbc0ed7c19071/examples/weather/grpc/module.go"><code>grpc/module.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="c1">/// Annotation used by the gRPC client module.</span>
<span class="kd">type</span> <span class="nx">GrpcClient</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">/// A module for providing gRPC client components.</span>
<span class="kd">type</span> <span class="nx">GrpcClientModule</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">GrpcClientModule</span><span class="p">)</span> <span class="nx">ProvideConnection</span><span class="p">(</span>
    <span class="nx">endpoint</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">GrpcClient</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">GrpcClient</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">connection</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="nx">endpoint</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">WithInsecure</span><span class="p">())</span>
    <span class="k">return</span> <span class="nx">connection</span><span class="p">,</span> <span class="nx">GrpcClient</span><span class="p">{},</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="https://github.com/Monnoroch/go-inject/blob/96ebd38a01cb954d5cdc8f4047bbbc0ed7c19071/examples/weather/ai/client.go"><code>ai/client.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="c1">/// Annotation used by the AI service client module.</span>
<span class="kd">type</span> <span class="nx">AiService</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">/// A module for providing AI service client components.</span>
<span class="kd">type</span> <span class="nx">AiServiceClientModule</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">AiServiceClientModule</span><span class="p">)</span> <span class="nx">ProvideGrpcClient</span><span class="p">(</span>
    <span class="nx">connection</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClient</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">aiproto</span><span class="p">.</span><span class="nx">AiClient</span><span class="p">,</span> <span class="nx">AiService</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">aiproto</span><span class="p">.</span><span class="nx">NewAiClient</span><span class="p">(</span><span class="nx">connection</span><span class="p">),</span> <span class="nx">AiService</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">AiServiceClientModule</span><span class="p">)</span> <span class="nx">ProvideAiClient</span><span class="p">(</span>
    <span class="nx">client</span> <span class="nx">aiproto</span><span class="p">.</span><span class="nx">AiClient</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">AiService</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">AiClient</span><span class="p">,</span> <span class="nx">AiService</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">AiClient</span><span class="p">{</span><span class="nx">RawAiClient</span><span class="p">:</span> <span class="nx">client</span><span class="p">},</span> <span class="nx">AiService</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="https://github.com/Monnoroch/go-inject/blob/96ebd38a01cb954d5cdc8f4047bbbc0ed7c19071/examples/weather/main.go"><code>main.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="c1">/// Annotation used by the weather prediction server module.</span>
<span class="kd">type</span> <span class="nx">WeatherPrediction</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">/// A module for providing a configured weather prediction server.</span>
<span class="kd">type</span> <span class="nx">WeatherPredictionServerModule</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">/// Provider returning the AI service endpoint, to be used by the gRPC client module.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">WeatherPredictionServerModule</span><span class="p">)</span> <span class="nx">ProvideGrpcEndpoint</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClient</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;ai-service:80&quot;</span><span class="p">,</span> <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClient</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">WeatherPredictionServerModule</span><span class="p">)</span> <span class="nx">ProvideServer</span><span class="p">(</span>
    <span class="nx">client</span> <span class="nx">ai</span><span class="p">.</span><span class="nx">AiClient</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">ai</span><span class="p">.</span><span class="nx">AiService</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Server</span><span class="p">,</span> <span class="nx">WeatherPrediction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Server</span><span class="p">{</span><span class="nx">AiClient</span><span class="p">:</span> <span class="nx">client</span><span class="p">},</span> <span class="nx">WeatherPrediction</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">injector</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">InjectorOf</span><span class="p">(</span>
        <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClientModule</span><span class="p">{},</span>
        <span class="nx">ai</span><span class="p">.</span><span class="nx">AiServiceClientModule</span><span class="p">{},</span>
        <span class="nx">WeatherPredictionServerModule</span><span class="p">{},</span>
    <span class="p">)</span>
    <span class="nx">weatherPredictionServer</span> <span class="o">:=</span> <span class="nx">injector</span><span class="p">.</span><span class="nx">MustGet</span><span class="p">(</span>
        <span class="nb">new</span><span class="p">(</span><span class="o">*</span><span class="nx">Server</span><span class="p">),</span> <span class="nx">WeatherPrediction</span><span class="p">{},</span>
    <span class="p">).(</span><span class="o">*</span><span class="nx">Server</span><span class="p">)</span>

    <span class="nx">server</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">NewServer</span><span class="p">()</span>
    <span class="nx">proto</span><span class="p">.</span><span class="nx">RegisterWeatherPredictionServer</span><span class="p">(</span>
        <span class="nx">server</span><span class="p">,</span>
        <span class="nx">weatherPredictionServer</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nx">listener</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listen</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;:80&quot;</span><span class="p">)</span>
    <span class="nx">server</span><span class="p">.</span><span class="nx">Serve</span><span class="p">(</span><span class="nx">listener</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Notice how all provided values and dependencies are now &quot;annotated&quot; using a second value with the annotation type, and how we request the <code>*Server</code> type with the <code>WeatherPrediction</code> annotation from the injector. By the way, since now we can have multiple providers of the same type, we can go even further and have a gRPC server provider:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/cbff69f2c7705c343d13b050cb613aaf5f941697/examples/weather/grpc/module.go"><code>grpc/module.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="o">...</span>

<span class="c1">/// Annotation used by the gRPC server module.</span>
<span class="kd">type</span> <span class="nx">GrpcServer</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">/// A module for providing gRPC server components.</span>
<span class="kd">type</span> <span class="nx">GrpcServerModule</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">GrpcServerModule</span><span class="p">)</span> <span class="nx">ProvideServer</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">Server</span><span class="p">,</span> <span class="nx">GrpcServer</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">NewServer</span><span class="p">(),</span> <span class="nx">GrpcServer</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="https://github.com/Monnoroch/go-inject/blob/cbff69f2c7705c343d13b050cb613aaf5f941697/examples/weather/main.go"><code>main.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="o">...</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">WeatherPredictionServerModule</span><span class="p">)</span> <span class="nx">ProvideGrpcServer</span><span class="p">(</span>
    <span class="nx">grpcServer</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">Server</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcServer</span><span class="p">,</span>
    <span class="nx">weatherPredictionServer</span> <span class="o">*</span><span class="nx">Server</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">WeatherPrediction</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">Server</span><span class="p">,</span> <span class="nx">WeatherPrediction</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">proto</span><span class="p">.</span><span class="nx">RegisterWeatherPredictionServer</span><span class="p">(</span>
        <span class="nx">grpcServer</span><span class="p">,</span>
        <span class="nx">weatherPredictionServer</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="nx">grpcServer</span><span class="p">,</span> <span class="nx">WeatherPrediction</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">injector</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">InjectorOf</span><span class="p">(</span>
        <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcServerModule</span><span class="p">{},</span>
        <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClientModule</span><span class="p">{},</span>
        <span class="nx">ai</span><span class="p">.</span><span class="nx">AiServiceClientModule</span><span class="p">{},</span>
        <span class="nx">WeatherPredictionServerModule</span><span class="p">{},</span>
    <span class="p">)</span>
    <span class="nx">server</span> <span class="o">:=</span> <span class="nx">injector</span><span class="p">.</span><span class="nx">MustGet</span><span class="p">(</span>
        <span class="nb">new</span><span class="p">(</span><span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">Server</span><span class="p">),</span> <span class="nx">WeatherPrediction</span><span class="p">{},</span>
    <span class="p">).(</span><span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">Server</span><span class="p">)</span>
    <span class="nx">listener</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listen</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;:80&quot;</span><span class="p">)</span>
    <span class="nx">server</span><span class="p">.</span><span class="nx">Serve</span><span class="p">(</span><span class="nx">listener</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Notice how we&#39;re not actually creating a gRPC server in the weather prediction module, but rather receive it as a dependency, configure it and return it back to the user with a different annotation. Pretty neat. This example might not look particularly impressive, but once you have tens of different components, command line flags, environment variables and configuration routines that can be reused in different contexts, restructuring code into providers and modules starts to provide value (no pun intended).</p>

<p>This is basically it. The library only has three core concepts: modules with providers for providing components, annotations to disambiguate values of identical types and the injector to wire these providers together. Now that we understand the core, let&#39;s dive in some more subtle features.</p>

<h3>Singletons</h3>

<p>Components often should be singletons: only have one instance for the whole program. In fact, in our example we already have this case: there should be only one gRPC connection to the AI service. Sure, we only inject it once, so it&#39;s fine now, but we might want to inject it in multiple components in the future. The code will still be correct, but will call the gRPC connection provider twice, which means it will create two gRPC connections, which might hurt performance and is certainly not what we want to do. We want the AI service connection to be a singleton. <code>go-inject</code> has a tool for that: cached providers. We can&#39;t actually make the gRPC connection a singleton because we might also want to connect to other services, so let&#39;s make the AI client a singleton. This can be done by prefixing the provider name with <code>ProvideCached</code> which will make this provider into a cached provider:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/e11885c373159ffdaf68fd705b81f69b69237f88/examples/weather/ai/client.go"><code>ai/client.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="o">...</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">AiServiceClientModule</span><span class="p">)</span> <span class="nx">ProvideCachedGrpcClient</span><span class="p">(</span>
    <span class="nx">connection</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClient</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">aiproto</span><span class="p">.</span><span class="nx">AiClient</span><span class="p">,</span> <span class="nx">AiService</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">aiproto</span><span class="p">.</span><span class="nx">NewAiClient</span><span class="p">(</span><span class="nx">connection</span><span class="p">),</span> <span class="nx">AiService</span><span class="p">{}</span>
<span class="p">}</span>
<span class="o">...</span>
</code></pre></div>
<p>Now the gRPC client for the AI service is cached and all components that depend on <code>AiClient</code> will get the same instance of <code>aiproto.AiClient</code>, so only one gRPC connection will be established. Note how this behaviour is not default. I have seen many production bugs because some things got cached when they shouldn&#39;t have been, so I decided that explicit is better than implicit and disabled caching by default.</p>

<h3>Private providers</h3>

<p>In the example above <code>AiServiceClientModule</code> provides our <code>AiClient</code> component and gRPC-generated <code>aiproto.AiClient</code> annotated with <code>AiService</code>. This is not actually what we wanted. We want to provide our <code>AiClient</code> component and make the generated dependency component an implementation detail that is not exposed to users of our module. I&#39;ve spent some time designing how this could be implemented; the options included special annotation modifiers and <code>ProvidePrivate</code> prefix. All these options didn&#39;t quite fit. They were all clumsy and hard to explain. So I scrapped everything and started from the basic principle of making the API feel native to Go developers. Surprisingly, I found that I don&#39;t have to do anything at all! One can just define a separate annotation for providers that should be private and make that annotation a private struct. That way we get module-scoped privacy rules native to Go and we get it for free: it&#39;s a zero-implementation and zero-documentation feature! Let&#39;s demonstrate it for our example:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/12df1c9bb04382afbb0ffad0b5394b654f07846b/examples/weather/ai/client.go"><code>ai/client.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="c1">/// Annotation used by the AI service client module.</span>
<span class="kd">type</span> <span class="nx">AiService</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">/// Annotation for private providers.</span>
<span class="kd">type</span> <span class="nx">private</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">/// A module for providing AI service client components.</span>
<span class="kd">type</span> <span class="nx">AiServiceClientModule</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">AiServiceClientModule</span><span class="p">)</span> <span class="nx">ProvideGrpcClient</span><span class="p">(</span>
    <span class="nx">connection</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">GrpcClient</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">aiproto</span><span class="p">.</span><span class="nx">AiClient</span><span class="p">,</span> <span class="nx">private</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">aiproto</span><span class="p">.</span><span class="nx">NewAiClient</span><span class="p">(</span><span class="nx">connection</span><span class="p">),</span> <span class="nx">private</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">AiServiceClientModule</span><span class="p">)</span> <span class="nx">ProvideAiClient</span><span class="p">(</span>
    <span class="nx">client</span> <span class="nx">aiproto</span><span class="p">.</span><span class="nx">AiClient</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">private</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">AiClient</span><span class="p">,</span> <span class="nx">AiService</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">AiClient</span><span class="p">{</span> <span class="nx">RawAiClient</span><span class="p">:</span> <span class="nx">aiClient</span> <span class="p">},</span> <span class="nx">AiService</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div>
<h3>Reducing boilerplate</h3>

<p>All code above is great but it is a little bit verbose. Especially it&#39;s too verbose for structs that are created by just putting dependencies in fields. This does not align with the goal of being concise. To make the code more concise I added a special tool for this case: automatic field injection. <code>go-inject</code> library comes with <code>autoinject</code> package with the <code>autoinject.AutoInjectModule</code> API for generating providers like these. <code>autoinject.AutoInjectModule</code> receives a type and returns a module that can provide that type by copying dependencies into it&#39;s fields. The catch here is that only public fields can be automatically injected. Auto-inject modules can also be configured with output and field annotations. For example:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kn">import</span> <span class="s">&quot;github.com/monnoroch/go-inject/auto&quot;</span>

<span class="nx">autoinject</span><span class="p">.</span><span class="nx">AutoInjectModule</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="nx">AiClient</span><span class="p">)).</span>
    <span class="nx">WithAnnotation</span><span class="p">(</span><span class="nx">AiService</span><span class="p">{})</span>
    <span class="nx">WithFieldAnnotations</span><span class="p">(</span><span class="kd">struct</span><span class="p">{</span>
        <span class="nx">RawAiClient</span> <span class="nx">private</span>
    <span class="p">}{}),</span>
</code></pre></div>
<p>generates a module with a provider that returns <code>AiClient</code> annotated with <code>AiService</code> and with <code>RawAiClient</code> field populated by a value of it&#39;s type in the <code>AiClient</code> struct, annotated with <code>private</code>. This is exactly what we had before in the <code>ProvideAiClient</code> provider, but now it&#39;s generated for us!</p>

<p>Let&#39;s transform our code to use auto-inject modules:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/3a3fd9034689933d975552776858515db1286bc3/examples/weather/ai/client.go"><code>ai/client.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="c1">/// A module for providing AI service client components.</span>
<span class="kd">type</span> <span class="nx">aiServiceClientModule</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">aiServiceClientModule</span><span class="p">)</span> <span class="nx">ProvideCachedGrpcClient</span><span class="p">(</span>
    <span class="nx">connection</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClient</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">aiproto</span><span class="p">.</span><span class="nx">AiClient</span><span class="p">,</span> <span class="nx">private</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">aiproto</span><span class="p">.</span><span class="nx">NewAiClient</span><span class="p">(</span><span class="nx">connection</span><span class="p">),</span> <span class="nx">private</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">AiServiceClientModule</span><span class="p">()</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">Module</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">CombineModules</span><span class="p">(</span>
        <span class="nx">aiServiceClientModule</span><span class="p">{},</span>
        <span class="nx">autoinject</span><span class="p">.</span><span class="nx">AutoInjectModule</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="nx">AiClient</span><span class="p">)).</span>
            <span class="nx">WithAnnotation</span><span class="p">(</span><span class="nx">AiService</span><span class="p">{}).</span>
            <span class="nx">WithFieldAnnotations</span><span class="p">(</span><span class="kd">struct</span> <span class="p">{</span>
                <span class="nx">RawAiClient</span> <span class="nx">private</span>
            <span class="p">}{}),</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="https://github.com/Monnoroch/go-inject/blob/3a3fd9034689933d975552776858515db1286bc3/examples/weather/main.go"><code>main.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="o">...</span>

<span class="c1">/// A module for providing a configured weather prediction server.</span>
<span class="kd">type</span> <span class="nx">weatherPredictionServerModule</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">/// Provider returning the AI service endpoint, to be used by the gRPC client module.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">weatherPredictionServerModule</span><span class="p">)</span> <span class="nx">ProvideGrpcEndpoint</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClient</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;ai-service:80&quot;</span><span class="p">,</span> <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClient</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">weatherPredictionServerModule</span><span class="p">)</span> <span class="nx">ProvideGrpcServer</span><span class="p">(</span>
    <span class="nx">grpcServer</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">Server</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcServer</span><span class="p">,</span>
    <span class="nx">weatherPredictionServer</span> <span class="o">*</span><span class="nx">Server</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">WeatherPrediction</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">Server</span><span class="p">,</span> <span class="nx">WeatherPrediction</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">proto</span><span class="p">.</span><span class="nx">RegisterWeatherPredictionServer</span><span class="p">(</span>
        <span class="nx">grpcServer</span><span class="p">,</span>
        <span class="nx">weatherPredictionServer</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="nx">grpcServer</span><span class="p">,</span> <span class="nx">WeatherPrediction</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">WeatherPredictionServerModule</span><span class="p">()</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">Module</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">CombineModules</span><span class="p">(</span>
        <span class="nx">weatherPredictionServerModule</span><span class="p">{},</span>
        <span class="nx">autoinject</span><span class="p">.</span><span class="nx">AutoInjectModule</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="o">*</span><span class="nx">Server</span><span class="p">)).</span>
            <span class="nx">WithAnnotation</span><span class="p">(</span><span class="nx">WeatherPrediction</span><span class="p">{}).</span>
            <span class="nx">WithFieldAnnotations</span><span class="p">(</span><span class="kd">struct</span> <span class="p">{</span>
                <span class="nx">AiClient</span> <span class="nx">ai</span><span class="p">.</span><span class="nx">AiService</span>
            <span class="p">}{}),</span>
    <span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">injector</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">InjectorOf</span><span class="p">(</span>
        <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClientModule</span><span class="p">{},</span>
        <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcServerModule</span><span class="p">{},</span>
        <span class="nx">ai</span><span class="p">.</span><span class="nx">AiServiceClientModule</span><span class="p">(),</span>
        <span class="nx">WeatherPredictionServerModule</span><span class="p">(),</span>
    <span class="p">)</span>

    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div>
<p>Okay, that&#39;s a lot of changes, let&#39;s go through them one-by-one. First of all, notice how we replaced creating module structs with function calls in the injector configuration and made our modules private, so that they can only be created by these helper functions. We did that because our AI client and weather prediction server modules are now not just structs, but are themselves lists of two modules each: the module we had before and an auto-inject module for providing the structs. Wrapping a collection of modules into a single module can be done with <code>inject.CombineModules</code> function. Only providers that do actual interesting work are left to be coded manually now. In this case we are reasonably sure that there will only be one component of type <code>AiClient</code> in our application, so we can simplify code even more by omitting it&#39;s annotations:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/0742f07184f92305a6273afa1893a850e1fd3ebc/examples/weather/ai/client.go"><code>ai/client.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">func</span> <span class="nx">AiServiceClientModule</span><span class="p">()</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">Module</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">CombineModules</span><span class="p">(</span>
        <span class="nx">aiServiceClientModule</span><span class="p">{},</span>
        <span class="nx">autoinject</span><span class="p">.</span><span class="nx">AutoInjectModule</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="nx">AiClient</span><span class="p">)).</span>
            <span class="nx">WithFieldAnnotations</span><span class="p">(</span><span class="kd">struct</span> <span class="p">{</span>
                <span class="nx">RawAiClient</span> <span class="nx">private</span>
            <span class="p">}{}),</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="https://github.com/Monnoroch/go-inject/blob/0742f07184f92305a6273afa1893a850e1fd3ebc/examples/weather/main.go"><code>main.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">weatherPredictionServerModule</span><span class="p">)</span> <span class="nx">ProvideGrpcServer</span><span class="p">(</span>
    <span class="nx">grpcServer</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">Server</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcServer</span><span class="p">,</span>
    <span class="nx">weatherPredictionServer</span> <span class="o">*</span><span class="nx">Server</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">autoinject</span><span class="p">.</span><span class="nx">Auto</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">Server</span><span class="p">,</span> <span class="nx">WeatherPrediction</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">proto</span><span class="p">.</span><span class="nx">RegisterWeatherPredictionServer</span><span class="p">(</span>
        <span class="nx">grpcServer</span><span class="p">,</span>
        <span class="nx">weatherPredictionServer</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="nx">grpcServer</span><span class="p">,</span> <span class="nx">WeatherPrediction</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">WeatherPredictionServerModule</span><span class="p">()</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">Module</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">CombineModules</span><span class="p">(</span>
        <span class="nx">weatherPredictionServerModule</span><span class="p">{},</span>
        <span class="nx">autoinject</span><span class="p">.</span><span class="nx">AutoInjectModule</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="o">*</span><span class="nx">Server</span><span class="p">)),</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Now auto-injected structs will be provided annotated with <code>autoinject.Auto</code>. In fact, we can simplify the code even further. Often when developing application components that are not meant to be used as a general purpose library, the author can provide default code for creating the component. With <code>go-inject</code> this can be done by implementing the <code>autoinject.AutoInjectable</code> interface. Let&#39;s do that for our AI client:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/3c3c205f097311b3e6d804b0704754dbfb791887/examples/weather/ai/client.go"><code>ai/client.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="nx">AiClient</span><span class="p">)</span> <span class="nx">ProvideAutoInjectAnnotations</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">struct</span><span class="p">{</span>
        <span class="nx">RawAiClient</span> <span class="nx">private</span>
    <span class="p">}{}</span>
<span class="p">}</span>
</code></pre></div>
<p>Now if we want to create <code>AiClient</code> configured with default dependencies, we don&#39;t need to specify the annotations any more:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/3c3c205f097311b3e6d804b0704754dbfb791887/examples/weather/ai/client.go"><code>ai/client.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">func</span> <span class="nx">AiServiceClientModule</span><span class="p">()</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">Module</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">CombineModules</span><span class="p">(</span>
        <span class="nx">aiServiceClientModule</span><span class="p">{},</span>
        <span class="nx">autoinject</span><span class="p">.</span><span class="nx">AutoInjectModule</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="nx">AiClient</span><span class="p">)),</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>With this design the author of the component can define default annotations for field dependencies, but the user can still override individual dependencies when creating an auto-inject module.</p>

<p><em>Implementing this interface is similar to creating an <code>@Inject</code> constructor for a class in Guice.</em></p>

<p>Again, all this does not seem like much, but once you have a lot of dependencies, it really adds up and auto-inject modules can reduce the code base significantly.</p>

<h3>Code reuse</h3>

<p>Ok, we&#39;ve got cloud, microservices and AI. What&#39;s missing? Blockchain, of course! As our startup turns into an evil money-sucking corporation, we will want to make our users pay for weather predictions. Fortunately, we use gRPC, so we can make a backwards-compatible change to the API that will allow us to bill users:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/76bb82094376c7d87f6b43accee131e930eb0752/examples/weather/proto/weather.proto"><code>weather.proto</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-proto" data-lang="proto"><span></span><span class="kd">message</span> <span class="nc">SpaceTimeLocation</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="na">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int64</span> <span class="na">timestamp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int64</span> <span class="na">user_id</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// we don&#39;t have funding to refactor it into an enclosing message for readability</span>
<span class="p">}</span>
</code></pre></div>
<p>Nice, now we can bill the user and reject requests without a user id. IPO, here we come! But first we need to implement this new feature. Fortunately, our cloud provider is a great one and it already provides a shared blockchain service our users can register in and authorize us to make payments with. Here is its API:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/76bb82094376c7d87f6b43accee131e930eb0752/examples/weather/proto/blockchain/blockchain.proto"><code>blockchain.proto</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-proto" data-lang="proto"><span></span><span class="kd">service</span> <span class="n">Blockchain</span> <span class="p">{</span>
    <span class="k">rpc</span> <span class="n">Pay</span><span class="p">(</span><span class="n">PayRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">PayResponse</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">PayRequest</span> <span class="p">{</span>
    <span class="kt">int64</span> <span class="na">from</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int64</span> <span class="k">to</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int64</span> <span class="na">amount_micro_eth</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">PayResponse</span> <span class="p">{}</span>
</code></pre></div>
<p>Here is how our new architecture will look like:</p>

<p><center>
    <img src="/images/posts/2018-10-22-go-inject-dependency-injection-library-for-go/architecture-2.svg"/>
</center>
<center>
Fig 2. Weather prediction service with billing architecture.
</center></p>

<p>Now let&#39;s use this service to implement billing customers:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/76bb82094376c7d87f6b43accee131e930eb0752/examples/weather/blockchain/client.go"><code>blockchain/client.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">type</span> <span class="nx">BlockchainClient</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">RawBlockchainClient</span> <span class="nx">blockchainproto</span><span class="p">.</span><span class="nx">BlockchainClient</span>
<span class="p">}</span>

<span class="c1">/// Make payment using the blockchain service.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">BlockchainClient</span><span class="p">)</span> <span class="nx">Pay</span><span class="p">(</span>
    <span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span>
    <span class="nx">userId</span> <span class="kt">int64</span><span class="p">,</span>
<span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">RawBlockchainClient</span><span class="p">.</span><span class="nx">Pay</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">blockchainproto</span><span class="p">.</span><span class="nx">PayRequest</span><span class="p">{</span>
        <span class="nx">From</span><span class="p">:</span>           <span class="nx">userId</span><span class="p">,</span>
        <span class="nx">To</span><span class="p">:</span>             <span class="mi">12345</span><span class="p">,</span> <span class="c1">// our app&#39;s user id; not enough funding to make it a flag</span>
        <span class="nx">AmountMicroEth</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">})</span>
    <span class="k">return</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div>
<p>And create a module fom providing it, similar to the <code>AiClient</code> module:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/76bb82094376c7d87f6b43accee131e930eb0752/examples/weather/blockchain/client.go"><code>blockchain/client.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="nx">BlockchainClient</span><span class="p">)</span> <span class="nx">ProvideAutoInjectAnnotations</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">RawBlockchainClient</span> <span class="nx">private</span>
    <span class="p">}{}</span>
<span class="p">}</span>

<span class="c1">/// Annotation used by the AI service client module.</span>
<span class="kd">type</span> <span class="nx">BlockchainService</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">/// Annotation for private providers.</span>
<span class="kd">type</span> <span class="nx">private</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">/// A module for providing AI service client components.</span>
<span class="kd">type</span> <span class="nx">blockchainServiceClientModule</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">blockchainServiceClientModule</span><span class="p">)</span> <span class="nx">ProvideCachedGrpcClient</span><span class="p">(</span>
    <span class="nx">connection</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClient</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">blockchainproto</span><span class="p">.</span><span class="nx">BlockchainClient</span><span class="p">,</span> <span class="nx">private</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">blockchainproto</span><span class="p">.</span><span class="nx">NewBlockchainClient</span><span class="p">(</span><span class="nx">connection</span><span class="p">),</span> <span class="nx">private</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">BlockchainServiceClientModule</span><span class="p">()</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">Module</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">CombineModules</span><span class="p">(</span>
        <span class="nx">blockchainServiceClientModule</span><span class="p">{},</span>
        <span class="nx">autoinject</span><span class="p">.</span><span class="nx">AutoInjectModule</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="nx">BlockchainClient</span><span class="p">)),</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Now we modify our weather prediction server to use the new component:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/76bb82094376c7d87f6b43accee131e930eb0752/examples/weather/main.go"><code>main.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">type</span> <span class="nx">Server</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">AiClient</span>         <span class="nx">ai</span><span class="p">.</span><span class="nx">AiClient</span>
    <span class="nx">BlockchainClient</span> <span class="nx">blockchain</span><span class="p">.</span><span class="nx">BlockchainClient</span>
<span class="p">}</span>

<span class="c1">/// Handler for the WeatherPrediction.Predict RPC.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nx">Predict</span><span class="p">(</span>
    <span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span>
    <span class="nx">request</span> <span class="o">*</span><span class="nx">proto</span><span class="p">.</span><span class="nx">SpaceTimeLocation</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">proto</span><span class="p">.</span><span class="nx">Weather</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nx">BlockchainClient</span><span class="p">.</span><span class="nx">Pay</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">GetUserId</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="nx">proto</span><span class="p">.</span><span class="nx">Weather</span><span class="p">{},</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;no money -- no weather!&quot;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">weather</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">AiClient</span><span class="p">.</span><span class="nx">AskForWeather</span><span class="p">(</span>
        <span class="nx">ctx</span><span class="p">,</span>
        <span class="nx">request</span><span class="p">.</span><span class="nx">GetLocation</span><span class="p">(),</span>
        <span class="nx">request</span><span class="p">.</span><span class="nx">GetTimestamp</span><span class="p">(),</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">proto</span><span class="p">.</span><span class="nx">Weather</span><span class="p">{</span><span class="nx">Weather</span><span class="p">:</span> <span class="nx">weather</span><span class="p">},</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div>
<p>And finally we update the weather prediction server module to inject and configure the new component:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/76bb82094376c7d87f6b43accee131e930eb0752/examples/weather/main.go"><code>main.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="c1">/// Provider returning the AI service endpoint, to be used by the gRPC client module.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">weatherPredictionServerModule</span><span class="p">)</span> <span class="nx">ProvideGrpcEndpoint</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClient</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;ai-service:80&quot;</span><span class="p">,</span> <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClient</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">/// Provider returning the blockchain service endpoint, to be used by the gRPC client module.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">weatherPredictionServerModule</span><span class="p">)</span> <span class="nx">ProvideBlockchainGrpcEndpoint</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClient</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;blockchain-service:80&quot;</span><span class="p">,</span> <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClient</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">injector</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">InjectorOf</span><span class="p">(</span>
        <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcServerModule</span><span class="p">{},</span>
        <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClientModule</span><span class="p">{},</span>
        <span class="nx">ai</span><span class="p">.</span><span class="nx">AiServiceClientModule</span><span class="p">(),</span>
        <span class="nx">blockchain</span><span class="p">.</span><span class="nx">BlockchainServiceClientModule</span><span class="p">(),</span>
        <span class="nx">WeatherPredictionServerModule</span><span class="p">(),</span>
    <span class="p">)</span>

    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div>
<p>Note how we don&#39;t need to modify <code>WeatherPredictionServerModule</code> because of automatic injection and only need to provide a new endpoint to configure a new gRPC connection to the blockchain service. But wait... now we provide two <code>string</code>-s annotated with <code>GrpcClient</code>. That&#39;s not good. It meand that to have a second gRPC client we now need a second gRPC client module with a separate annotation, so there goes our general purpose library idea. Or does it? To make creating general purpose libraries possible <code>go-inject</code> has a feature called annotation rewriting. Basically, what we want to achieve here is to be able to write a gRPC client module once and then be able to instantiate it with different annotations for different clients. This is exactly what annotation rewriting lets us do. Let&#39;s reimplement the gRPC client module with it:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/1367d662a3ae945b2de9fbf3f795c411605f5035/examples/weather/grpc/module.go"><code>grpc/module.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kn">import</span> <span class="s">&quot;github.com/monnoroch/go-inject/rewrite&quot;</span>

<span class="c1">/// Annotation used by the gRPC client module.</span>
<span class="kd">type</span> <span class="nx">grpcClient</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="c1">/// A module for providing gRPC client components.</span>
<span class="kd">type</span> <span class="nx">grpcClientModule</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">grpcClientModule</span><span class="p">)</span> <span class="nx">ProvideConnection</span><span class="p">(</span>
    <span class="nx">endpoint</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">grpcClient</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">grpcClient</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">connection</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="nx">endpoint</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">connection</span><span class="p">,</span> <span class="nx">grpcClient</span><span class="p">{},</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">GrpcClientModule</span><span class="p">(</span><span class="nx">annotation</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">Annotation</span><span class="p">)</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">Module</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">rewrite</span><span class="p">.</span><span class="nx">RewriteAnnotations</span><span class="p">(</span>
        <span class="nx">grpcClientModule</span><span class="p">{},</span>
        <span class="nx">rewrite</span><span class="p">.</span><span class="nx">AnnotationsMapping</span><span class="p">{</span>
            <span class="nx">grpcClient</span><span class="p">{}:</span> <span class="nx">annotation</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>You can immediately spot the trick with making the module private and providing a helper function to create it now, but what does the new do? <code>rewrite.RewriteAnnotations</code> is a module wrapper function that receives a module and returns it&#39;s copy where all annotations that are keys in the annotations mapping get replaced with corresponding values. In this case <code>GrpcClientModule(ai.AiService{})</code> will return a copy of <code>grpcClientModule</code> with a provider that receives a <code>string</code> annotated with <code>ai.AiService</code> and returns a <code>*grpc.ClientConn</code> annotated with <code>ai.AiService</code>. Let&#39;s change our code function to use it:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/1367d662a3ae945b2de9fbf3f795c411605f5035/examples/weather/ai/client.go"><code>ai/client.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="o">...</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">aiServiceClientModule</span><span class="p">)</span> <span class="nx">ProvideCachedGrpcClient</span><span class="p">(</span>
    <span class="nx">connection</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">AiService</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">aiproto</span><span class="p">.</span><span class="nx">AiClient</span><span class="p">,</span> <span class="nx">private</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">aiproto</span><span class="p">.</span><span class="nx">NewAiClient</span><span class="p">(</span><span class="nx">connection</span><span class="p">),</span> <span class="nx">private</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="https://github.com/Monnoroch/go-inject/blob/1367d662a3ae945b2de9fbf3f795c411605f5035/examples/weather/blockchain/client.go"><code>blockchain/client.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="o">...</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">blockchainServiceClientModule</span><span class="p">)</span> <span class="nx">ProvideCachedGrpcClient</span><span class="p">(</span>
    <span class="nx">connection</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">BlockchainService</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">blockchainproto</span><span class="p">.</span><span class="nx">BlockchainClient</span><span class="p">,</span> <span class="nx">private</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">blockchainproto</span><span class="p">.</span><span class="nx">NewBlockchainClient</span><span class="p">(</span><span class="nx">connection</span><span class="p">),</span> <span class="nx">private</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="https://github.com/Monnoroch/go-inject/blob/1367d662a3ae945b2de9fbf3f795c411605f5035/examples/weather/main.go"><code>main.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="o">...</span>

<span class="c1">/// Provider returning the AI service endpoint, to be used by the gRPC client module.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">weatherPredictionServerModule</span><span class="p">)</span> <span class="nx">ProvideGrpcEndpoint</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="nx">ai</span><span class="p">.</span><span class="nx">AiService</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;ai-service:80&quot;</span><span class="p">,</span> <span class="nx">ai</span><span class="p">.</span><span class="nx">AiService</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">/// Provider returning the blockchain service endpoint, to be used by the gRPC client module.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">weatherPredictionServerModule</span><span class="p">)</span> <span class="nx">ProvideBlockchainGrpcEndpoint</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="nx">blockchain</span><span class="p">.</span><span class="nx">BlockchainService</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;blockchain-service:80&quot;</span><span class="p">,</span> <span class="nx">blockchain</span><span class="p">.</span><span class="nx">BlockchainService</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">injector</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">InjectorOf</span><span class="p">(</span>
        <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcServerModule</span><span class="p">{},</span>
        <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClientModule</span><span class="p">(</span><span class="nx">ai</span><span class="p">.</span><span class="nx">AiService</span><span class="p">{}),</span>
        <span class="nx">grpcinject</span><span class="p">.</span><span class="nx">GrpcClientModule</span><span class="p">(</span><span class="nx">blockchain</span><span class="p">.</span><span class="nx">BlockchainService</span><span class="p">{}),</span>
        <span class="nx">ai</span><span class="p">.</span><span class="nx">AiServiceClientModule</span><span class="p">(),</span>
        <span class="nx">blockchain</span><span class="p">.</span><span class="nx">BlockchainServiceClientModule</span><span class="p">(),</span>
        <span class="nx">WeatherPredictionServerModule</span><span class="p">(),</span>
    <span class="p">)</span>

    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div>
<p>Now both gRPC connections will be configured with correct endpoints and we have a reusable general purpose library for creating gRPC connections.</p>

<h3>Lazy dependencies</h3>

<p>Let&#39;s look at a different problem. We want to have a development instance of our service for the team members to test new features, which will not require it&#39;s users to actually pay anything to us. Since <code>blockchainproto.BlockchainClient</code> is an interface, we can have a second non-gRPC implementation that always authorizes payments:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/39db1150e48abdcfb34ac2fa211e8aca3cbf422a/examples/weather/blockchain/fake_client.go"><code>blockchain/fake_client.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">type</span> <span class="nx">develBlockchainClient</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">/// Make all payments succeed.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="nx">develBlockchainClient</span><span class="p">)</span> <span class="nx">Pay</span><span class="p">(</span>
    <span class="nx">_</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span>
    <span class="nx">_</span> <span class="o">*</span><span class="nx">blockchainproto</span><span class="p">.</span><span class="nx">PayRequest</span><span class="p">,</span>
    <span class="nx">_</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">blockchainproto</span><span class="p">.</span><span class="nx">PayResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">blockchainproto</span><span class="p">.</span><span class="nx">PayResponse</span><span class="p">{},</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div>
<p>Okay, we have the logic, let&#39;s configure our <code>BlockchainClient</code> to use <code>develBlockchainClient</code> instead of the generated <code>blockchainproto.BlockchainClient</code>. We will configure it with a boolean flag provided by the weather prediction server module and select the <code>blockchainproto.BlockchainClient</code> implementation conditionally:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/39db1150e48abdcfb34ac2fa211e8aca3cbf422a/examples/weather/blockchain/client.go"><code>blockchain/client.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">blockchainServiceClientModule</span><span class="p">)</span> <span class="nx">ProvideCachedGrpcClient</span><span class="p">(</span>
    <span class="nx">connection</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">BlockchainService</span><span class="p">,</span>
    <span class="nx">develClient</span> <span class="nx">develBlockchainClient</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">private</span><span class="p">,</span>
    <span class="nx">develInstance</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">BlockchainService</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">blockchainproto</span><span class="p">.</span><span class="nx">BlockchainClient</span><span class="p">,</span> <span class="nx">private</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">develInstance</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">develClient</span><span class="p">,</span> <span class="nx">private</span><span class="p">{}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">blockchainproto</span><span class="p">.</span><span class="nx">NewBlockchainClient</span><span class="p">(</span><span class="nx">connection</span><span class="p">),</span> <span class="nx">private</span><span class="p">{}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">BlockchainServiceClientModule</span><span class="p">()</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">Module</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">CombineModules</span><span class="p">(</span>
        <span class="nx">blockchainServiceClientModule</span><span class="p">{},</span>
        <span class="nx">autoinject</span><span class="p">.</span><span class="nx">AutoInjectModule</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="nx">BlockchainClient</span><span class="p">)),</span>
        <span class="nx">autoinject</span><span class="p">.</span><span class="nx">AutoInjectModule</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="nx">develBlockchainClient</span><span class="p">)).</span>
            <span class="nx">WithAnnotation</span><span class="p">(</span><span class="nx">private</span><span class="p">{}),</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="https://github.com/Monnoroch/go-inject/blob/39db1150e48abdcfb34ac2fa211e8aca3cbf422a/examples/weather/main.go"><code>main.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">weatherPredictionServerModule</span><span class="p">)</span> <span class="nx">ProvideIsDevelInstance</span><span class="p">()</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="nx">blockchain</span><span class="p">.</span><span class="nx">BlockchainService</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">blockchain</span><span class="p">.</span><span class="nx">BlockchainService</span><span class="p">{}</span> <span class="c1">// TODO: make it into a flag</span>
<span class="p">}</span>
</code></pre></div>
<p>The code looks correct, but there is a problem there. Even if <code>develInstance</code> is true, the gRPC version of <code>blockchainproto.BlockchainClient</code> is still injected, which means the gRPC connection is still established, even though we don&#39;t use it. And it&#39;s not just a performance issue, this also means that we can&#39;t run the devel instance locally or in environments where there&#39;s no blockchain service endpoint provided. We need to be able to inject dependencies conditionally. In this case, only if <code>develInstance</code> is false. <code>go-inject</code> provides this facility with the lazy dependencies feature. To inject a dependency lazily, just inject a function that returns it instead. Here&#39;s the code:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/2cab46cf96e92679a455c3cc4855a56a31115db2/examples/weather/blockchain/client.go"><code>blockchain/client.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">blockchainServiceClientModule</span><span class="p">)</span> <span class="nx">ProvideCachedGrpcClient</span><span class="p">(</span>
    <span class="nx">connection</span> <span class="kd">func</span><span class="p">()</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">BlockchainService</span><span class="p">,</span>
    <span class="nx">develClient</span> <span class="nx">develBlockchainClient</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">private</span><span class="p">,</span>
    <span class="nx">develInstance</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">BlockchainService</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">blockchainproto</span><span class="p">.</span><span class="nx">BlockchainClient</span><span class="p">,</span> <span class="nx">private</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">develInstance</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">develClient</span><span class="p">,</span> <span class="nx">private</span><span class="p">{}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">blockchainproto</span><span class="p">.</span><span class="nx">NewBlockchainClient</span><span class="p">(</span><span class="nx">connection</span><span class="p">()),</span> <span class="nx">private</span><span class="p">{}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Yep, it&#39;s that simple. Now we only create the client (and thus establish the gRPC connection) when we&#39;re not in the devel instance. It just works. As of now, lazy value functions can only be called in the provider that injects them and will panic if you try to store them and call later. This behaviour might be changed in the future though. There is a catch, however: this feature means that injecting functions is not supported, they are always treated as lazy dependencies. It&#39;s not a major issue though, because you can still inject alias types of functions:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">type</span> <span class="nx">Predicate</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span>

<span class="kd">type</span> <span class="nx">Absolute</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="nx">Predicate</span><span class="p">)</span> <span class="nx">ProvideAbs</span><span class="p">(</span>
    <span class="nx">value</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">Annotation</span><span class="p">,</span>
    <span class="nx">isPositive</span> <span class="nx">Predicate</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">Annotation</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="nx">Absolute</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">isPositive</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">Absolute</span><span class="p">{}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="nx">value</span><span class="p">,</span> <span class="nx">Absolute</span><span class="p">{}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>This will inject an actual function, not a lazy <code>int</code> value.</p>

<h3>Hacking API</h3>

<p>Still not enough features? One of your common patterns doesn&#39;t have a convenient tool? Perhaps, you are feeling like a hacker today? Remember the goal of this library being expressive? It is! In fact, the library has a feature specifically for you: dynamic modules. Dynamic module is a very simple concept: instead of writing providers as methods on regular static modules, implement the <code>inject.DynamicModule</code> interface with just one method and create providers at runtime with anonymous functions or reflection. Let&#39;s take a look at a simple example for generating providers for constants:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/8fa599cb0ed4f19848fff8bcb7006344f76b1329/examples/weather/constant/module.go"><code>constant/module.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">type</span> <span class="nx">constantModule</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">value</span>      <span class="kd">interface</span><span class="p">{}</span>
    <span class="nx">annotation</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">Annotation</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="nx">constantModule</span><span class="p">)</span> <span class="nx">Providers</span><span class="p">()</span> <span class="p">([]</span><span class="nx">inject</span><span class="p">.</span><span class="nx">Provider</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">annotationType</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">annotation</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[]</span><span class="nx">inject</span><span class="p">.</span><span class="nx">Provider</span><span class="p">{</span><span class="nx">inject</span><span class="p">.</span><span class="nx">NewProvider</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">MakeFunc</span><span class="p">(</span>
        <span class="nx">reflect</span><span class="p">.</span><span class="nx">FuncOf</span><span class="p">(</span>
            <span class="p">[]</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Type</span><span class="p">{},</span>
            <span class="p">[]</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Type</span><span class="p">{</span>
                <span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">value</span><span class="p">),</span>
                <span class="nx">annotationType</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="kc">false</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="kd">func</span><span class="p">(</span><span class="nx">_</span> <span class="p">[]</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="p">[]</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">[]</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">{</span>
                <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">value</span><span class="p">),</span>
                <span class="nx">reflect</span><span class="p">.</span><span class="nx">Zero</span><span class="p">(</span><span class="nx">annotationType</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">),</span>
    <span class="p">)},</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">/// Creates a module that provides a constant value with a specified annotation.</span>
<span class="kd">func</span> <span class="nx">ConstantModule</span><span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">annotation</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">Annotation</span><span class="p">)</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">Module</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">constantModule</span><span class="p">{</span><span class="nx">value</span><span class="p">:</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">annotation</span><span class="p">:</span> <span class="nx">annotation</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>It&#39;s a very simple dynamic module that generates a single provider with reflection. That provider doesn&#39;t have any dependencies and just provides a constant value with a specified annotation. Let&#39;s use it to provide our endpoints and the devel flag instead of writing providers manually:</p>

<p><a href="https://github.com/Monnoroch/go-inject/blob/8fa599cb0ed4f19848fff8bcb7006344f76b1329/examples/weather/main.go"><code>main.go</code> (code)</a>:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">func</span> <span class="nx">WeatherPredictionServerModule</span><span class="p">()</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">Module</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">inject</span><span class="p">.</span><span class="nx">CombineModules</span><span class="p">(</span>
        <span class="nx">weatherPredictionServerModule</span><span class="p">{},</span>
        <span class="nx">constant</span><span class="p">.</span><span class="nx">ConstantModule</span><span class="p">(</span><span class="s">&quot;ai-service:80&quot;</span><span class="p">,</span> <span class="nx">ai</span><span class="p">.</span><span class="nx">AiService</span><span class="p">{}),</span>
        <span class="nx">constant</span><span class="p">.</span><span class="nx">ConstantModule</span><span class="p">(</span><span class="s">&quot;blockchain-service:80&quot;</span><span class="p">,</span> <span class="nx">blockchain</span><span class="p">.</span><span class="nx">BlockchainService</span><span class="p">{}),</span>
        <span class="nx">constant</span><span class="p">.</span><span class="nx">ConstantModule</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">blockchain</span><span class="p">.</span><span class="nx">BlockchainService</span><span class="p">{}),</span>
        <span class="nx">autoinject</span><span class="p">.</span><span class="nx">AutoInjectModule</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="o">*</span><span class="nx">Server</span><span class="p">)),</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>In fact, both automatic injection module and annotation rewrite wrapper and even regular static modules are implemented using this API, so it&#39;s very powerful and basically provides a way to implement any feature you&#39;ve seen in other DI frameworks (not that you necessarily should though).</p>

<p><em>If you feel that your provider generator would be useful to most users of <code>go-inject</code>, feel free to submit a design document with a proposal and a reference implementation to add it to the core repository.</em></p>

<h3>Implementation</h3>

<p>If you&#39;re still reading this post, then you probably interested enough to remember the goal of implementation being transparent. Simple implementation is very important for any piece of software and even more so for libraries to be used by other developers. If you followed the post, you might already have a feeling how the library is implemented (which is a good indicator that it is, in fact, transparent!). There are two stages: configuring an injector and providing values.</p>

<h4>Configuring an injector</h4>

<p>The first stage is the <code>inject.InjectorOf</code> call. It receives a list of modules, and collects dynamic providers from all of them into one big map, keyed by (value type, annotation type) pairs. For static modules it first wraps them with a struct implementing the <code>inject.DynamicModule</code> interface to extract providers from struct methods with reflection. This stage also does all provider validation, making sure that providers are named properly and that there&#39;s the right number of inputs and outputs.</p>

<h4>Providing values</h4>

<p>The second stage is providing values using <code>injector.Get</code> and <code>injector.MustGet</code> methods. These are also pretty straightforward: they receive a value type, an annotation type, search the providers map for a corresponding provider, recursively provide it&#39;s dependencies and inject them into that provider. For lazy dependencies, they inject a function calling <code>injector.Get</code> instead. There&#39;s a bit of complexity around cached providers, but it&#39;s not critical for understanding the implementation.</p>

<p>The whole description fits a couple of paragraphs and it doesn&#39;t even omit much detail. The whole library is under 3kloc with tests, so the implementation is very compact as well.</p>

<h3>Alternatives</h3>

<p>Now that we&#39;ve seen what we can do with <code>go-inject</code>, let&#39;s look at the alternatives. To my best knowledge, there are five of them (as of Q3 2018):</p>

<ul>
<li><a href="https://github.com/mustafaakin/gongular">gongular</a></li>
<li><a href="https://github.com/facebookgo/inject">facebookgo/inject</a></li>
<li><a href="https://github.com/magic003/alice">alice</a></li>
<li><a href="https://github.com/impinj/go-inject">impinj/go-inject</a></li>
<li><a href="https://github.com/alecthomas/inject">alecthomas/inject</a></li>
</ul>

<h4>Gongular</h4>

<p><a href="https://github.com/mustafaakin/gongular">Gongular</a> is a web framework that includes DI. I found this problematic:</p>

<ul>
<li>being a framework, it violates the &quot;do one thing&quot; principle</li>
<li>if you already use another web framework, you can&#39;t use it for DI</li>
<li>it provides DI for data as well as component dependencies. My experience shows that it is bug-prone and not easily debuggable</li>
</ul>

<p>Because of these reasons I rejected this package immediately when researching the problem.</p>

<h4><code>impinj/go-inject</code>, <code>facebookgo/inject</code> and <code>alice</code></h4>

<p>These three packages are quite similar. They all use struct tags instead of <code>go-inject</code>-style annotations. The obvious problem with this interface is that you can&#39;t provide non-struct values, which is critical for providing configuration flags, endpoints and the like. The less obvious problem is that the interface is based on annotation strings and is thus untyped, which means that the compiler will not be able to verify your code. This also means &quot;private&quot; providers are impossible, which breaks encapsulation. In addition to that, <code>impinj/go-inject</code> and <code>facebookgo/inject</code> also have another problem: they require you to actually annotate the struct itself, rather than a separate entity (a module) and thus these libraries will not work with the existing code. <code>alice</code> does not have this flaw as annotations are moved to separate structs, called modules.</p>

<h4><code>alecthomas/inject</code></h4>

<p>This project is the most similar one to <code>go-inject</code>. It also provides the struct-based modules interface, but it doesn&#39;t provide a way to provide multiple values of the same type (which is supported by all other libraries, including <code>go-inject</code>). It also provides ways to generate providers in runtime, but they are tailored to particular use-cases, such as binding a constant, rather than providing a generic interface for extending the library.</p>

<h3>Conclusion</h3>

<p>This library is used in production Go backend software for more than a year and engineers who use it enjoy it a lot as it helps them to manage complexity. The effort to open source it is new, and it was significantly redesigned for simplicity in the process. It is definitely not stable yet, but it is very thoroughly tested both with automated tests and in production, so feel free to try it out and submit improvements on <a href="https://github.com/Monnoroch/go-inject">github</a>.</p>

<h3>Literature</h3>

<ul>
<li>Motivation for <a href="https://github.com/google/guice/wiki/Motivation">Guice</a>, that explains what is DI, why do you want it and how to use it correctly</li>
</ul>


</div>

<div class="pagination">
  
  
    <a href="/posts/2018/04/03/generative-adversarial-networks.html" class="right arrow">&#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>

    </main>
    <footer>
        <span>
            &copy; <time datetime="2018-10-27 19:30:08 +0000">2018</time> You can find me on <a href="https://github.com/Monnoroch">GitHub</a>.
        </span>
    </footer>
    <script src="/scripts/responsive.js" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']]
            }
        });
    </script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
